<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="SingletonPattern_Title" xml:space="preserve">
    <value>Singleton Pattern</value>
  </data>
  <data name="SingletonPattern_Creational" xml:space="preserve">
    <value>CrÃ©ation</value>
  </data>
  <data name="SingletonPattern_DescriptionTitle" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="SingletonPattern_Description" xml:space="preserve">
    <value>The Singleton pattern ensures a class has only one instance and provides a global point of access to it.</value>
  </data>
  <data name="SingletonPattern_WhenToUseTitle" xml:space="preserve">
    <value>When to use</value>
  </data>
  <data name="SingletonPattern_WhenToUse1" xml:space="preserve">
    <value>When exactly one instance of a class is needed</value>
  </data>
  <data name="SingletonPattern_WhenToUse2" xml:space="preserve">
    <value>For configuration managers or logging services</value>
  </data>
  <data name="SingletonPattern_WhenToUse3" xml:space="preserve">
    <value>To control access to shared resources</value>
  </data>
  <data name="SingletonPattern_InteractiveTitle" xml:space="preserve">
    <value>ðŸŽ® Interactive Example</value>
  </data>
  <data name="SingletonPattern_InteractiveDesc" xml:space="preserve">
    <value>Click the button to create a Singleton instance. Notice that multiple clicks always return the same instance!</value>
  </data>
  <data name="SingletonPattern_InteractiveButton" xml:space="preserve">
    <value>Create Singleton Instance</value>
  </data>
  <data name="SingletonPattern_CodeTitle" xml:space="preserve">
    <value>Code Example</value>
  </data>
  <data name="SingletonPattern_ProsTitle" xml:space="preserve">
    <value>Pros</value>
  </data>
  <data name="SingletonPattern_Pros1" xml:space="preserve">
    <value>Guarantees a single instance</value>
  </data>
  <data name="SingletonPattern_Pros2" xml:space="preserve">
    <value>Global access point</value>
  </data>
  <data name="SingletonPattern_Pros3" xml:space="preserve">
    <value>Lazy initialization</value>
  </data>
  <data name="SingletonPattern_ConsTitle" xml:space="preserve">
    <value>Cons</value>
  </data>
  <data name="SingletonPattern_Cons1" xml:space="preserve">
    <value>Hard to test</value>
  </data>
  <data name="SingletonPattern_Cons2" xml:space="preserve">
    <value>Global state issues</value>
  </data>
  <data name="SingletonPattern_Cons3" xml:space="preserve">
    <value>Thread safety concerns</value>
  </data>
  <data name="FactoryPattern_Title" xml:space="preserve">
    <value>Factory Pattern</value>
  </data>
  <data name="FactoryPattern_Creational" xml:space="preserve">
    <value>Creational</value>
  </data>
  <data name="FactoryPattern_DescriptionTitle" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="FactoryPattern_Description" xml:space="preserve">
    <value>The Factory pattern provides an interface for creating objects without exposing the creation logic to the client. It delegates instantiation to specialized factory classes.</value>
  </data>
  <data name="FactoryPattern_WhenToUseTitle" xml:space="preserve">
    <value>When to use</value>
  </data>
  <data name="FactoryPattern_WhenToUse1" xml:space="preserve">
    <value>When object creation logic is complex</value>
  </data>
  <data name="FactoryPattern_WhenToUse2" xml:space="preserve">
    <value>When you need to decouple object creation from usage</value>
  </data>
  <data name="FactoryPattern_WhenToUse3" xml:space="preserve">
    <value>To create families of related objects</value>
  </data>
  <data name="FactoryPattern_InteractiveTitle" xml:space="preserve">
    <value>Interactive Example</value>
  </data>
  <data name="FactoryPattern_InteractiveDesc" xml:space="preserve">
    <value>Select a vehicle type and create it using the factory:</value>
  </data>
  <data name="FactoryPattern_PickerTitle" xml:space="preserve">
    <value>Choose a vehicle type</value>
  </data>
  <data name="FactoryPattern_PickerCar" xml:space="preserve">
    <value>Car</value>
  </data>
  <data name="FactoryPattern_PickerBike" xml:space="preserve">
    <value>Bike</value>
  </data>
  <data name="FactoryPattern_PickerPlane" xml:space="preserve">
    <value>Plane</value>
  </data>
  <data name="FactoryPattern_InteractiveButton" xml:space="preserve">
    <value>Create Vehicle</value>
  </data>
  <data name="FactoryPattern_CodeTitle" xml:space="preserve">
    <value>Code Example</value>
  </data>
  <data name="FactoryPattern_RealWorldTitle" xml:space="preserve">
    <value>Real-World Scenario</value>
  </data>
  <data name="FactoryPattern_RealWorldDesc" xml:space="preserve">
    <value>Creating documents in office software: WordFactory creates .docx, SpreadsheetFactory creates .xlsx - same interface, different implementations.</value>
  </data>
  <data name="FactoryPattern_ProsTitle" xml:space="preserve">
    <value>Pros</value>
  </data>
  <data name="FactoryPattern_Pros1" xml:space="preserve">
    <value>â€¢ Low coupling</value>
  </data>
  <data name="FactoryPattern_Pros2" xml:space="preserve">
    <value>â€¢ Easy to extend</value>
  </data>
  <data name="FactoryPattern_Pros3" xml:space="preserve">
    <value>â€¢ Centralized creation</value>
  </data>
  <data name="FactoryPattern_ConsTitle" xml:space="preserve">
    <value>Cons</value>
  </data>
  <data name="FactoryPattern_Cons1" xml:space="preserve">
    <value>â€¢ More classes</value>
  </data>
  <data name="FactoryPattern_Cons2" xml:space="preserve">
    <value>â€¢ Increased complexity</value>
  </data>
  <data name="FactoryPattern_Cons3" xml:space="preserve">
    <value>â€¢ Factory can become large</value>
  </data>
  <data name="AbstractFactoryPattern_Title" xml:space="preserve">
    <value>Abstract Factory Pattern</value>
  </data>
  <data name="AbstractFactoryPattern_Creational" xml:space="preserve">
    <value>Creational</value>
  </data>
  <data name="AbstractFactoryPattern_Description" xml:space="preserve">
    <value>The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.</value>
  </data>
  <data name="AbstractFactoryPattern_WhenToUse1" xml:space="preserve">
    <value>Create families of related products</value>
  </data>
  <data name="AbstractFactoryPattern_WhenToUse2" xml:space="preserve">
    <value>Support multiple UI themes or platforms</value>
  </data>
  <data name="AbstractFactoryPattern_WhenToUse3" xml:space="preserve">
    <value>Ensure product compatibility</value>
  </data>
  <data name="AbstractFactoryPattern_InteractiveDesc" xml:space="preserve">
    <value>Create a family of UI components for different platforms:</value>
  </data>
  <data name="AbstractFactoryPattern_InteractiveButton" xml:space="preserve">
    <value>Create Windows UI Family</value>
  </data>
  <data name="AbstractFactoryPattern_RealWorldTitle" xml:space="preserve">
    <value>Real-World Example</value>
  </data>
  <data name="AbstractFactoryPattern_RealWorldDesc" xml:space="preserve">
    <value>Cross-platform UI frameworks: Create UI components for Windows, Mac, and Linux that integrate seamlessly with each platform while using the same creation interface.</value>
  </data>
  <data name="AbstractFactoryPattern_Pros1" xml:space="preserve">
    <value>â€¢ Product compatibility</value>
  </data>
  <data name="AbstractFactoryPattern_Pros2" xml:space="preserve">
    <value>â€¢ Easy family switching</value>
  </data>
  <data name="AbstractFactoryPattern_Pros3" xml:space="preserve">
    <value>â€¢ Consistent interface</value>
  </data>
  <data name="AbstractFactoryPattern_Cons1" xml:space="preserve">
    <value>â€¢ Complex structure</value>
  </data>
  <data name="AbstractFactoryPattern_Cons2" xml:space="preserve">
    <value>â€¢ Many classes</value>
  </data>
  <data name="AbstractFactoryPattern_Cons3" xml:space="preserve">
    <value>â€¢ Difficult to extend</value>
  </data>
  <data name="AdapterPattern_Title" xml:space="preserve">
    <value>Adapter Pattern</value>
  </data>
  <data name="AdapterPattern_Structural" xml:space="preserve">
    <value>Structural</value>
  </data>
  <data name="AdapterPattern_Description" xml:space="preserve">
    <value>The Adapter pattern converts the interface of a class into another interface clients expect. It allows incompatible interfaces to work together.</value>
  </data>
  <data name="AdapterPattern_WhenToUse1" xml:space="preserve">
    <value>Integrate legacy code with new systems</value>
  </data>
  <data name="AdapterPattern_WhenToUse2" xml:space="preserve">
    <value>Make incompatible interfaces work together</value>
  </data>
  <data name="AdapterPattern_WhenToUse3" xml:space="preserve">
    <value>Use third-party libraries with different interfaces</value>
  </data>
  <data name="AdapterPattern_InteractiveDesc" xml:space="preserve">
    <value>Use an adapter to make incompatible interfaces work together:</value>
  </data>
  <data name="AdapterPattern_InteractiveButton" xml:space="preserve">
    <value>Use Adapter</value>
  </data>
  <data name="AdapterPattern_RealWorldDesc" xml:space="preserve">
    <value>Power plug adapters: European devices (220V) can work with American outlets (110V) through an adapter that converts the interface while maintaining functionality.</value>
  </data>
  <data name="AdapterPattern_Pros1" xml:space="preserve">
    <value>â€¢ Reuses existing code</value>
  </data>
  <data name="AdapterPattern_Pros2" xml:space="preserve">
    <value>â€¢ Single responsibility</value>
  </data>
  <data name="AdapterPattern_Pros3" xml:space="preserve">
    <value>â€¢ Open/closed principle</value>
  </data>
  <data name="AdapterPattern_Cons1" xml:space="preserve">
    <value>â€¢ Increased complexity</value>
  </data>
  <data name="AdapterPattern_Cons2" xml:space="preserve">
    <value>â€¢ Performance overhead</value>
  </data>
  <data name="AdapterPattern_Cons3" xml:space="preserve">
    <value>â€¢ May be simpler to refactor</value>
  </data>
  <data name="BuilderPattern_Title" xml:space="preserve">
    <value>Builder Pattern</value>
  </data>
  <data name="BuilderPattern_Description" xml:space="preserve">
    <value>The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.</value>
  </data>
  <data name="BuilderPattern_WhenToUse1" xml:space="preserve">
    <value>When creating complex objects with many parameters</value>
  </data>
  <data name="BuilderPattern_WhenToUse2" xml:space="preserve">
    <value>When object construction requires multiple steps</value>
  </data>
  <data name="BuilderPattern_WhenToUse3" xml:space="preserve">
    <value>To avoid telescoping constructors</value>
  </data>
  <data name="BuilderPattern_InteractiveDesc" xml:space="preserve">
    <value>Build a product step by step:</value>
  </data>
  <data name="BuilderPattern_InteractiveButton" xml:space="preserve">
    <value>Build Product</value>
  </data>
  <data name="BuilderPattern_Pros1" xml:space="preserve">
    <value>â€¢ Fluent interface</value>
  </data>
  <data name="BuilderPattern_Pros2" xml:space="preserve">
    <value>â€¢ Supports immutability</value>
  </data>
  <data name="BuilderPattern_Pros3" xml:space="preserve">
    <value>â€¢ Clear construction</value>
  </data>
  <data name="BuilderPattern_Cons1" xml:space="preserve">
    <value>â€¢ More code</value>
  </data>
  <data name="BuilderPattern_Cons2" xml:space="preserve">
    <value>â€¢ Overkill for simple objects</value>
  </data>
  <data name="BuilderPattern_Cons3" xml:space="preserve">
    <value>â€¢ Builder class needed</value>
  </data>
  <data name="BridgePattern_Title" xml:space="preserve">
    <value>Bridge Pattern</value>
  </data>
  <data name="BridgePattern_Description" xml:space="preserve">
    <value>The Bridge pattern separates an abstraction from its implementation so they can vary independently. It uses composition over inheritance.</value>
  </data>
  <data name="BridgePattern_WhenToUse1" xml:space="preserve">
    <value>Avoid permanent binding between abstraction and implementation</value>
  </data>
  <data name="BridgePattern_WhenToUse2" xml:space="preserve">
    <value>Both abstraction and implementation should be extensible</value>
  </data>
  <data name="BridgePattern_WhenToUse3" xml:space="preserve">
    <value>Implementation changes shouldn't affect clients</value>
  </data>
  <data name="BridgePattern_InteractiveDesc" xml:space="preserve">
    <value>Draw shapes with different rendering implementations:</value>
  </data>
  <data name="BridgePattern_InteractiveButton" xml:space="preserve">
    <value>Draw with Bridge</value>
  </data>
  <data name="BridgePattern_RealWorldDesc" xml:space="preserve">
    <value>GUI frameworks: Separate window abstractions (Window, Dialog) from platform implementations (Windows API, macOS API, Linux X11) - same window types work across all platforms.</value>
  </data>
  <data name="BridgePattern_Pros1" xml:space="preserve">
    <value>â€¢ Decouples interface from implementation</value>
  </data>
  <data name="BridgePattern_Pros2" xml:space="preserve">
    <value>â€¢ Runtime binding</value>
  </data>
  <data name="BridgePattern_Pros3" xml:space="preserve">
    <value>â€¢ Independent extensions</value>
  </data>
  <data name="BridgePattern_Cons1" xml:space="preserve">
    <value>â€¢ Increased complexity</value>
  </data>
  <data name="BridgePattern_Cons2" xml:space="preserve">
    <value>â€¢ More classes</value>
  </data>
  <data name="BridgePattern_Cons3" xml:space="preserve">
    <value>â€¢ Indirection overhead</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Title" xml:space="preserve">
    <value>Chain of Responsibility Pattern</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Behavioral" xml:space="preserve">
    <value>Behavioral</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Description" xml:space="preserve">
    <value>The Chain of Responsibility pattern processes requests along a chain of handlers. Each handler decides to process the request or pass it to the next handler.</value>
  </data>
  <data name="ChainOfResponsibilityPattern_WhenToUse1" xml:space="preserve">
    <value>When multiple objects can handle a request</value>
  </data>
  <data name="ChainOfResponsibilityPattern_WhenToUse2" xml:space="preserve">
    <value>The handler isn't known in advance</value>
  </data>
  <data name="ChainOfResponsibilityPattern_WhenToUse3" xml:space="preserve">
    <value>Decouple sender from receiver</value>
  </data>
  <data name="ChainOfResponsibilityPattern_InteractiveDesc" xml:space="preserve">
    <value>Test different requests in the responsibility chain:</value>
  </data>
  <data name="ChainOfResponsibilityPattern_InteractiveButton" xml:space="preserve">
    <value>Process Requests</value>
  </data>
  <data name="ChainOfResponsibilityPattern_RealWorldDesc" xml:space="preserve">
    <value>Customer service: ticket â†’ level 1 support â†’ level 2 â†’ manager. Each level can resolve or escalate based on complexity.</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Pros1" xml:space="preserve">
    <value>â€¢ Flexible decoupling</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Pros2" xml:space="preserve">
    <value>â€¢ Dynamic chain</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Pros3" xml:space="preserve">
    <value>â€¢ Single responsibility</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Cons1" xml:space="preserve">
    <value>â€¢ No handling guarantee</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Cons2" xml:space="preserve">
    <value>â€¢ Performance impact</value>
  </data>
  <data name="ChainOfResponsibilityPattern_Cons3" xml:space="preserve">
    <value>â€¢ Difficult debugging</value>
  </data>
  <data name="CommandPattern_Title" xml:space="preserve">
    <value>Command Pattern</value>
  </data>
  <data name="CommandPattern_Description" xml:space="preserve">
    <value>The Command pattern encapsulates a request as an object, allowing you to parameterize actions, queue them, and support undo operations.</value>
  </data>
  <data name="CommandPattern_WhenToUse1" xml:space="preserve">
    <value>Decouple sender from receiver of a request</value>
  </data>
  <data name="CommandPattern_WhenToUse2" xml:space="preserve">
    <value>Support undo/redo operations</value>
  </data>
  <data name="CommandPattern_WhenToUse3" xml:space="preserve">
    <value>Log or queue requests</value>
  </data>
  <data name="CommandPattern_InteractiveDesc" xml:space="preserve">
    <value>Control a light with commands:</value>
  </data>
  <data name="CommandPattern_InteractiveButton" xml:space="preserve">
    <value>Execute Commands</value>
  </data>
  <data name="CommandPattern_RealWorldDesc" xml:space="preserve">
    <value>Universal remote: each button encapsulates a command (turn on TV, change channel, adjust volume) without knowing device details.</value>
  </data>
  <data name="CommandPattern_Pros1" xml:space="preserve">
    <value>â€¢ Complete decoupling</value>
  </data>
  <data name="CommandPattern_Pros2" xml:space="preserve">
    <value>â€¢ Undo/redo support</value>
  </data>
  <data name="CommandPattern_Pros3" xml:space="preserve">
    <value>â€¢ Command composition</value>
  </data>
  <data name="CommandPattern_Cons1" xml:space="preserve">
    <value>â€¢ Increased class count</value>
  </data>
  <data name="CommandPattern_Cons2" xml:space="preserve">
    <value>â€¢ Additional complexity</value>
  </data>
  <data name="CommandPattern_Cons3" xml:space="preserve">
    <value>â€¢ Indirection</value>
  </data>
  <data name="CompositePattern_Title" xml:space="preserve">
    <value>Composite Pattern</value>
  </data>
  <data name="CompositePattern_Description" xml:space="preserve">
    <value>The Composite pattern composes objects into tree structures to represent part-whole hierarchies. It treats individual objects and compositions uniformly.</value>
  </data>
  <data name="CompositePattern_WhenToUse1" xml:space="preserve">
    <value>Represent part-whole hierarchies of objects</value>
  </data>
  <data name="CompositePattern_WhenToUse2" xml:space="preserve">
    <value>Treat individual objects and compositions uniformly</value>
  </data>
  <data name="CompositePattern_WhenToUse3" xml:space="preserve">
    <value>Complex tree structures with recursive operations</value>
  </data>
  <data name="CompositePattern_InteractiveDesc" xml:space="preserve">
    <value>Build a composite tree structure:</value>
  </data>
  <data name="CompositePattern_InteractiveButton" xml:space="preserve">
    <value>Show Structure</value>
  </data>
  <data name="CompositePattern_RealWorldDesc" xml:space="preserve">
    <value>File system: folders can contain files or other folders. Same interface to list contents, whether it's a simple file or a folder with sub-elements.</value>
  </data>
  <data name="CompositePattern_Pros1" xml:space="preserve">
    <value>â€¢ Uniform interface</value>
  </data>
  <data name="CompositePattern_Pros2" xml:space="preserve">
    <value>â€¢ Natural recursive structures</value>
  </data>
  <data name="CompositePattern_Pros3" xml:space="preserve">
    <value>â€¢ Easy to add elements</value>
  </data>
  <data name="CompositePattern_Cons1" xml:space="preserve">
    <value>â€¢ Interface may be too general</value>
  </data>
  <data name="CompositePattern_Cons2" xml:space="preserve">
    <value>â€¢ Hard to restrict components</value>
  </data>
  <data name="CompositePattern_Cons3" xml:space="preserve">
    <value>â€¢ Complexity for simple types</value>
  </data>
  <data name="DecoratorPattern_Title" xml:space="preserve">
    <value>Decorator Pattern</value>
  </data>
  <data name="DecoratorPattern_Description" xml:space="preserve">
    <value>The Decorator pattern dynamically adds functionality to an object by wrapping it in a decorator object.</value>
  </data>
  <data name="DecoratorPattern_WhenToUse1" xml:space="preserve">
    <value>To dynamically add responsibilities to objects</value>
  </data>
  <data name="DecoratorPattern_WhenToUse2" xml:space="preserve">
    <value>When inheritance isn't practical or becomes too complex</value>
  </data>
  <data name="DecoratorPattern_WhenToUse3" xml:space="preserve">
    <value>To create flexible combinations of features</value>
  </data>
  <data name="DecoratorPattern_InteractiveDesc" xml:space="preserve">
    <value>Add decorations to enrich an object:</value>
  </data>
  <data name="DecoratorPattern_InteractiveButton" xml:space="preserve">
    <value>Add Decoration</value>
  </data>
  <data name="DecoratorPattern_Pros1" xml:space="preserve">
    <value>â€¢ Flexible feature addition</value>
  </data>
  <data name="DecoratorPattern_Pros2" xml:space="preserve">
    <value>â€¢ Alternative to inheritance</value>
  </data>
  <data name="DecoratorPattern_Pros3" xml:space="preserve">
    <value>â€¢ Multiple combinations possible</value>
  </data>
  <data name="DecoratorPattern_Pros4" xml:space="preserve">
    <value>â€¢ Open/closed principle</value>
  </data>
  <data name="DecoratorPattern_Cons1" xml:space="preserve">
    <value>â€¢ Many small classes</value>
  </data>
  <data name="DecoratorPattern_Cons2" xml:space="preserve">
    <value>â€¢ Code complexity</value>
  </data>
  <data name="DecoratorPattern_Cons3" xml:space="preserve">
    <value>â€¢ Decorator order matters</value>
  </data>
  <data name="FacadePattern_Title" xml:space="preserve">
    <value>Facade Pattern</value>
  </data>
  <data name="FacadePattern_Description" xml:space="preserve">
    <value>The Facade pattern provides a simplified interface to a set of complex subsystems, making the system easier to use.</value>
  </data>
  <data name="FacadePattern_WhenToUse1" xml:space="preserve">
    <value>To simplify access to complex subsystems</value>
  </data>
  <data name="FacadePattern_WhenToUse2" xml:space="preserve">
    <value>To reduce dependencies between clients and subsystems</value>
  </data>
  <data name="FacadePattern_WhenToUse3" xml:space="preserve">
    <value>To create abstraction layers</value>
  </data>
  <data name="FacadePattern_InteractiveDesc" xml:space="preserve">
    <value>Use the facade to simplify access:</value>
  </data>
  <data name="FacadePattern_InteractiveButton" xml:space="preserve">
    <value>Use Facade</value>
  </data>
  <data name="FacadePattern_Pros1" xml:space="preserve">
    <value>â€¢ Simplifies interface</value>
  </data>
  <data name="FacadePattern_Pros2" xml:space="preserve">
    <value>â€¢ Reduces coupling</value>
  </data>
  <data name="FacadePattern_Pros3" xml:space="preserve">
    <value>â€¢ Isolates complexity</value>
  </data>
  <data name="FacadePattern_Pros4" xml:space="preserve">
    <value>â€¢ Eases usage</value>
  </data>
  <data name="FacadePattern_Cons1" xml:space="preserve">
    <value>â€¢ Can become a god object</value>
  </data>
  <data name="FacadePattern_Cons2" xml:space="preserve">
    <value>â€¢ Loss of flexibility</value>
  </data>
  <data name="FacadePattern_Cons3" xml:space="preserve">
    <value>â€¢ Overhead if misused</value>
  </data>
  <data name="FlyweightPattern_Title" xml:space="preserve">
    <value>Flyweight Pattern</value>
  </data>
  <data name="FlyweightPattern_Description" xml:space="preserve">
    <value>The Flyweight pattern shares objects to save memory by pooling common intrinsic state across multiple objects.</value>
  </data>
  <data name="FlyweightPattern_WhenToUse1" xml:space="preserve">
    <value>When the application uses a large number of similar objects</value>
  </data>
  <data name="FlyweightPattern_WhenToUse2" xml:space="preserve">
    <value>To reduce memory consumption</value>
  </data>
  <data name="FlyweightPattern_WhenToUse3" xml:space="preserve">
    <value>When objects have shareable intrinsic state</value>
  </data>
  <data name="FlyweightPattern_InteractiveDesc" xml:space="preserve">
    <value>Use Flyweight to share objects:</value>
  </data>
  <data name="FlyweightPattern_InteractiveButton" xml:space="preserve">
    <value>Use Flyweight</value>
  </data>
  <data name="FlyweightPattern_Pros1" xml:space="preserve">
    <value>â€¢ Memory savings</value>
  </data>
  <data name="FlyweightPattern_Pros2" xml:space="preserve">
    <value>â€¢ Performance improvement</value>
  </data>
  <data name="FlyweightPattern_Pros3" xml:space="preserve">
    <value>â€¢ Centralized object management</value>
  </data>
  <data name="FlyweightPattern_Pros4" xml:space="preserve">
    <value>â€¢ Reduced duplication</value>
  </data>
  <data name="FlyweightPattern_Cons1" xml:space="preserve">
    <value>â€¢ Increased code complexity</value>
  </data>
  <data name="FlyweightPattern_Cons2" xml:space="preserve">
    <value>â€¢ Concurrency management</value>
  </data>
  <data name="FlyweightPattern_Cons3" xml:space="preserve">
    <value>â€¢ Intrinsic/extrinsic state separation</value>
  </data>
  <data name="ProxyPattern_Title" xml:space="preserve">
    <value>Proxy Pattern</value>
  </data>
  <data name="ProxyPattern_Description" xml:space="preserve">
    <value>The Proxy pattern provides a substitute or intermediary for another object to control access, add features, or delay instantiation.</value>
  </data>
  <data name="ProxyPattern_WhenToUse1" xml:space="preserve">
    <value>To control access to an expensive object</value>
  </data>
  <data name="ProxyPattern_WhenToUse2" xml:space="preserve">
    <value>For lazy loading (deferred initialization)</value>
  </data>
  <data name="ProxyPattern_WhenToUse3" xml:space="preserve">
    <value>To add a security or logging layer</value>
  </data>
  <data name="ProxyPattern_InteractiveDesc" xml:space="preserve">
    <value>Access the object via the proxy:</value>
  </data>
  <data name="ProxyPattern_InteractiveButton" xml:space="preserve">
    <value>Access via Proxy</value>
  </data>
  <data name="ProxyPattern_Pros1" xml:space="preserve">
    <value>â€¢ Access control</value>
  </data>
  <data name="ProxyPattern_Pros2" xml:space="preserve">
    <value>â€¢ Lazy initialization</value>
  </data>
  <data name="ProxyPattern_Pros3" xml:space="preserve">
    <value>â€¢ Feature addition</value>
  </data>
  <data name="ProxyPattern_Pros4" xml:space="preserve">
    <value>â€¢ Real object protection</value>
  </data>
  <data name="ProxyPattern_Cons1" xml:space="preserve">
    <value>â€¢ Increases complexity</value>
  </data>
  <data name="ProxyPattern_Cons2" xml:space="preserve">
    <value>â€¢ Can slow responses</value>
  </data>
  <data name="ProxyPattern_Cons3" xml:space="preserve">
    <value>â€¢ Maintenance of two classes</value>
  </data>
  <data name="PrototypePattern_Title" xml:space="preserve">
    <value>Prototype Pattern</value>
  </data>
  <data name="PrototypePattern_Creational" xml:space="preserve">
    <value>Creational</value>
  </data>
  <data name="PrototypePattern_Description" xml:space="preserve">
    <value>The Prototype pattern creates new objects by copying an existing object, called a prototype. This is useful when object creation is expensive or complex.</value>
  </data>
  <data name="PrototypePattern_WhenToUse1" xml:space="preserve">
    <value>Object creation is expensive</value>
  </data>
  <data name="PrototypePattern_WhenToUse2" xml:space="preserve">
    <value>You need to create many similar objects</value>
  </data>
  <data name="PrototypePattern_WhenToUse3" xml:space="preserve">
    <value>Avoid subclasses for object creation</value>
  </data>
  <data name="PrototypePattern_InteractiveDesc" xml:space="preserve">
    <value>Clone an object instead of creating a new one:</value>
  </data>
  <data name="PrototypePattern_InteractiveButton" xml:space="preserve">
    <value>Clone Object</value>
  </data>
  <data name="PrototypePattern_RealWorldTitle" xml:space="preserve">
    <value>Real-World Example</value>
  </data>
  <data name="PrototypePattern_RealWorldDesc" xml:space="preserve">
    <value>Document templates: Clone a template document with predefined formatting and styles instead of starting from scratch each time.</value>
  </data>
  <data name="PrototypePattern_Pros1" xml:space="preserve">
    <value>â€¢ Fast object creation</value>
  </data>
  <data name="PrototypePattern_Pros2" xml:space="preserve">
    <value>â€¢ Reduces subclassing</value>
  </data>
  <data name="PrototypePattern_Pros3" xml:space="preserve">
    <value>â€¢ Runtime flexibility</value>
  </data>
  <data name="PrototypePattern_Pros4" xml:space="preserve">
    <value>â€¢ Improved performance</value>
  </data>
  <data name="PrototypePattern_Cons1" xml:space="preserve">
    <value>â€¢ Deep copy complexity</value>
  </data>
  <data name="PrototypePattern_Cons2" xml:space="preserve">
    <value>â€¢ Circular references</value>
  </data>
  <data name="PrototypePattern_Cons3" xml:space="preserve">
    <value>â€¢ Clone method maintenance</value>
  </data>
  <data name="InterpreterPattern_Title" xml:space="preserve">
    <value>Interpreter Pattern</value>
  </data>
  <data name="InterpreterPattern_Description" xml:space="preserve">
    <value>The Interpreter pattern defines a representation for a grammar and an interpreter to process sentences in that grammar.</value>
  </data>
  <data name="InterpreterPattern_WhenToUse1" xml:space="preserve">
    <value>To interpret a simple language or grammar</value>
  </data>
  <data name="InterpreterPattern_WhenToUse2" xml:space="preserve">
    <value>When grammar is simple and performance is not critical</value>
  </data>
  <data name="InterpreterPattern_WhenToUse3" xml:space="preserve">
    <value>To evaluate expressions or queries</value>
  </data>
  <data name="InterpreterPattern_InteractiveDesc" xml:space="preserve">
    <value>Interpret a mathematical expression:</value>
  </data>
  <data name="InterpreterPattern_InteractiveButton" xml:space="preserve">
    <value>Interpret '1+2'</value>
  </data>
  <data name="InterpreterPattern_Pros1" xml:space="preserve">
    <value>â€¢ Easily extensible grammar</value>
  </data>
  <data name="InterpreterPattern_Pros2" xml:space="preserve">
    <value>â€¢ Clear separation of rules</value>
  </data>
  <data name="InterpreterPattern_Pros3" xml:space="preserve">
    <value>â€¢ Easy to implement</value>
  </data>
  <data name="InterpreterPattern_Pros4" xml:space="preserve">
    <value>â€¢ Flexibility</value>
  </data>
  <data name="InterpreterPattern_Cons1" xml:space="preserve">
    <value>â€¢ Complex grammar = many classes</value>
  </data>
  <data name="InterpreterPattern_Cons2" xml:space="preserve">
    <value>â€¢ Limited performance</value>
  </data>
  <data name="InterpreterPattern_Cons3" xml:space="preserve">
    <value>â€¢ Difficult maintenance if large</value>
  </data>
  <data name="IteratorPattern_Title" xml:space="preserve">
    <value>Iterator Pattern</value>
  </data>
  <data name="IteratorPattern_Behavioral" xml:space="preserve">
    <value>Behavioral</value>
  </data>
  <data name="IteratorPattern_Description" xml:space="preserve">
    <value>The Iterator pattern allows traversing a collection without exposing its internal structure.</value>
  </data>
  <data name="IteratorPattern_WhenToUse1" xml:space="preserve">
    <value>To traverse collections without exposing their structure</value>
  </data>
  <data name="IteratorPattern_WhenToUse2" xml:space="preserve">
    <value>Support multiple traversal types</value>
  </data>
  <data name="IteratorPattern_WhenToUse3" xml:space="preserve">
    <value>Provide a uniform interface for different collections</value>
  </data>
  <data name="IteratorPattern_InteractiveDesc" xml:space="preserve">
    <value>Traverse the collection:</value>
  </data>
  <data name="IteratorPattern_InteractiveButton" xml:space="preserve">
    <value>Traverse Collection</value>
  </data>
  <data name="IteratorPattern_Pros1" xml:space="preserve">
    <value>â€¢ Single responsibility</value>
  </data>
  <data name="IteratorPattern_Pros2" xml:space="preserve">
    <value>â€¢ Open/closed principle</value>
  </data>
  <data name="IteratorPattern_Pros3" xml:space="preserve">
    <value>â€¢ Simultaneous traversals</value>
  </data>
  <data name="IteratorPattern_Cons1" xml:space="preserve">
    <value>â€¢ Can be overkill for simple collections</value>
  </data>
  <data name="IteratorPattern_Cons2" xml:space="preserve">
    <value>â€¢ Less efficient than direct access</value>
  </data>
  <data name="MediatorPattern_Title" xml:space="preserve">
    <value>Mediator Pattern</value>
  </data>
  <data name="MediatorPattern_Description" xml:space="preserve">
    <value>The Mediator pattern reduces dependencies between objects by centralizing their communications through a mediator.</value>
  </data>
  <data name="MediatorPattern_WhenToUse1" xml:space="preserve">
    <value>When objects communicate in complex ways</value>
  </data>
  <data name="MediatorPattern_WhenToUse2" xml:space="preserve">
    <value>To reduce dependencies between components</value>
  </data>
  <data name="MediatorPattern_WhenToUse3" xml:space="preserve">
    <value>To reuse objects independently</value>
  </data>
  <data name="MediatorPattern_InteractiveDesc" xml:space="preserve">
    <value>Communicate via mediator:</value>
  </data>
  <data name="MediatorPattern_InteractiveButton" xml:space="preserve">
    <value>Send Message</value>
  </data>
  <data name="MediatorPattern_RealWorldDesc" xml:space="preserve">
    <value>Airport control tower: aircraft don't communicate directly with each other, they all go through the control tower that coordinates takeoffs and landings.</value>
  </data>
  <data name="MediatorPattern_Pros1" xml:space="preserve">
    <value>â€¢ Reduces coupling</value>
  </data>
  <data name="MediatorPattern_Pros2" xml:space="preserve">
    <value>â€¢ Centralizes communications</value>
  </data>
  <data name="MediatorPattern_Pros3" xml:space="preserve">
    <value>â€¢ Facilitates reuse</value>
  </data>
  <data name="MediatorPattern_Cons1" xml:space="preserve">
    <value>â€¢ Mediator can become complex</value>
  </data>
  <data name="MediatorPattern_Cons2" xml:space="preserve">
    <value>â€¢ Single point of failure</value>
  </data>
  <data name="MementoPattern_Title" xml:space="preserve">
    <value>Memento Pattern</value>
  </data>
  <data name="MementoPattern_Description" xml:space="preserve">
    <value>The Memento pattern captures and externalizes an object's internal state so it can be restored later.</value>
  </data>
  <data name="MementoPattern_WhenToUse1" xml:space="preserve">
    <value>To implement undo/redo</value>
  </data>
  <data name="MementoPattern_WhenToUse2" xml:space="preserve">
    <value>To save and restore object state</value>
  </data>
  <data name="MementoPattern_WhenToUse3" xml:space="preserve">
    <value>When direct access would violate encapsulation</value>
  </data>
  <data name="MementoPattern_InteractiveDesc" xml:space="preserve">
    <value>Save and restore state:</value>
  </data>
  <data name="MementoPattern_InteractiveButton" xml:space="preserve">
    <value>Modify and Undo</value>
  </data>
  <data name="MementoPattern_RealWorldDesc" xml:space="preserve">
    <value>Text editor: saves document state at each major modification to enable undo (Ctrl+Z) and return to a previous state.</value>
  </data>
  <data name="MementoPattern_Pros1" xml:space="preserve">
    <value>â€¢ Preserves encapsulation</value>
  </data>
  <data name="MementoPattern_Pros2" xml:space="preserve">
    <value>â€¢ Simplifies the originator</value>
  </data>
  <data name="MementoPattern_Pros3" xml:space="preserve">
    <value>â€¢ Undo/redo support</value>
  </data>
  <data name="MementoPattern_Cons1" xml:space="preserve">
    <value>â€¢ Memory consumption</value>
  </data>
  <data name="MementoPattern_Cons2" xml:space="preserve">
    <value>â€¢ Creation/restoration cost</value>
  </data>
  <data name="ObserverPattern_Title" xml:space="preserve">
    <value>Observer Pattern</value>
  </data>
  <data name="ObserverPattern_Description" xml:space="preserve">
    <value>The Observer pattern defines a one-to-many dependency where multiple objects are automatically notified of state changes.</value>
  </data>
  <data name="ObserverPattern_WhenToUse1" xml:space="preserve">
    <value>When a change requires multiple updates</value>
  </data>
  <data name="ObserverPattern_WhenToUse2" xml:space="preserve">
    <value>To implement event-driven systems</value>
  </data>
  <data name="ObserverPattern_WhenToUse3" xml:space="preserve">
    <value>When observed objects don't know observers</value>
  </data>
  <data name="ObserverPattern_InteractiveDesc" xml:space="preserve">
    <value>Observe changes:</value>
  </data>
  <data name="ObserverPattern_InteractiveButton" xml:space="preserve">
    <value>Modify Value</value>
  </data>
  <data name="ObserverPattern_RealWorldDesc" xml:space="preserve">
    <value>Newsletter: subscribers (observers) are automatically notified when a new article (subject) is published. Each can subscribe or unsubscribe freely.</value>
  </data>
  <data name="ObserverPattern_Pros1" xml:space="preserve">
    <value>â€¢ Loose coupling</value>
  </data>
  <data name="ObserverPattern_Pros2" xml:space="preserve">
    <value>â€¢ Broadcast support</value>
  </data>
  <data name="ObserverPattern_Pros3" xml:space="preserve">
    <value>â€¢ Open/closed principle</value>
  </data>
  <data name="ObserverPattern_Cons1" xml:space="preserve">
    <value>â€¢ Random notification order</value>
  </data>
  <data name="ObserverPattern_Cons2" xml:space="preserve">
    <value>â€¢ Potential memory leaks</value>
  </data>
  <data name="StatePattern_Title" xml:space="preserve">
    <value>State Pattern</value>
  </data>
  <data name="StatePattern_Description" xml:space="preserve">
    <value>The State pattern allows an object to alter its behavior when its internal state changes.</value>
  </data>
  <data name="StatePattern_WhenToUse1" xml:space="preserve">
    <value>When behavior depends on state</value>
  </data>
  <data name="StatePattern_WhenToUse2" xml:space="preserve">
    <value>To avoid large conditional statements</value>
  </data>
  <data name="StatePattern_WhenToUse3" xml:space="preserve">
    <value>When state transitions are complex</value>
  </data>
  <data name="StatePattern_InteractiveDesc" xml:space="preserve">
    <value>Change state:</value>
  </data>
  <data name="StatePattern_InteractiveButton" xml:space="preserve">
    <value>Change State</value>
  </data>
  <data name="StatePattern_RealWorldDesc" xml:space="preserve">
    <value>Order state machine: New â†’ Processing â†’ Shipped â†’ Delivered. Each state has specific actions (cancel only possible if New or Processing).</value>
  </data>
  <data name="StatePattern_Pros1" xml:space="preserve">
    <value>â€¢ Single responsibility</value>
  </data>
  <data name="StatePattern_Pros2" xml:space="preserve">
    <value>â€¢ Open/closed principle</value>
  </data>
  <data name="StatePattern_Pros3" xml:space="preserve">
    <value>â€¢ Simplifies complex code</value>
  </data>
  <data name="StatePattern_Cons1" xml:space="preserve">
    <value>â€¢ Can be overkill for few states</value>
  </data>
  <data name="StatePattern_Cons2" xml:space="preserve">
    <value>â€¢ Increases number of classes</value>
  </data>
  <data name="StrategyPattern_Title" xml:space="preserve">
    <value>Strategy Pattern</value>
  </data>
  <data name="StrategyPattern_Description" xml:space="preserve">
    <value>The Strategy pattern defines a family of algorithms, encapsulates each, and makes them interchangeable.</value>
  </data>
  <data name="StrategyPattern_WhenToUse1" xml:space="preserve">
    <value>To use different variants of an algorithm</value>
  </data>
  <data name="StrategyPattern_WhenToUse2" xml:space="preserve">
    <value>When you have many similar classes</value>
  </data>
  <data name="StrategyPattern_WhenToUse3" xml:space="preserve">
    <value>To isolate business logic from implementation details</value>
  </data>
  <data name="StrategyPattern_InteractiveDesc" xml:space="preserve">
    <value>Choose a strategy:</value>
  </data>
  <data name="StrategyPattern_InteractiveButton" xml:space="preserve">
    <value>Apply Strategy</value>
  </data>
  <data name="StrategyPattern_RealWorldDesc" xml:space="preserve">
    <value>Payment methods: credit card, PayPal, cryptocurrency. Same payment interface, different implementations depending on chosen strategy.</value>
  </data>
  <data name="StrategyPattern_Pros1" xml:space="preserve">
    <value>â€¢ Interchangeable algorithms</value>
  </data>
  <data name="StrategyPattern_Pros2" xml:space="preserve">
    <value>â€¢ Detail isolation</value>
  </data>
  <data name="StrategyPattern_Pros3" xml:space="preserve">
    <value>â€¢ Alternative to inheritance</value>
  </data>
  <data name="StrategyPattern_Cons1" xml:space="preserve">
    <value>â€¢ Increases number of classes</value>
  </data>
  <data name="StrategyPattern_Cons2" xml:space="preserve">
    <value>â€¢ Client must know strategies</value>
  </data>
  <data name="TemplateMethodPattern_Title" xml:space="preserve">
    <value>Template Method Pattern</value>
  </data>
  <data name="TemplateMethodPattern_Description" xml:space="preserve">
    <value>The Template Method pattern defines the skeleton of an algorithm in a method, delegating some steps to subclasses.</value>
  </data>
  <data name="TemplateMethodPattern_WhenToUse1" xml:space="preserve">
    <value>When you have an algorithm with variations</value>
  </data>
  <data name="TemplateMethodPattern_WhenToUse2" xml:space="preserve">
    <value>To avoid code duplication</value>
  </data>
  <data name="TemplateMethodPattern_WhenToUse3" xml:space="preserve">
    <value>To control extension points</value>
  </data>
  <data name="TemplateMethodPattern_InteractiveDesc" xml:space="preserve">
    <value>Execute template:</value>
  </data>
  <data name="TemplateMethodPattern_InteractiveButton" xml:space="preserve">
    <value>Execute Template</value>
  </data>
  <data name="TemplateMethodPattern_RealWorldDesc" xml:space="preserve">
    <value>Beverage preparation: tea and coffee follow same steps (boil water, prepare, pour, add condiments) but details vary.</value>
  </data>
  <data name="TemplateMethodPattern_Pros1" xml:space="preserve">
    <value>â€¢ Code reuse</value>
  </data>
  <data name="TemplateMethodPattern_Pros2" xml:space="preserve">
    <value>â€¢ Algorithm control</value>
  </data>
  <data name="TemplateMethodPattern_Pros3" xml:space="preserve">
    <value>â€¢ Easy to understand</value>
  </data>
  <data name="TemplateMethodPattern_Cons1" xml:space="preserve">
    <value>â€¢ Limited by inheritance</value>
  </data>
  <data name="TemplateMethodPattern_Cons2" xml:space="preserve">
    <value>â€¢ Can violate substitution principle</value>
  </data>
  <data name="VisitorPattern_Title" xml:space="preserve">
    <value>Visitor Pattern</value>
  </data>
  <data name="VisitorPattern_Description" xml:space="preserve">
    <value>The Visitor pattern allows adding new operations to objects without modifying their classes.</value>
  </data>
  <data name="VisitorPattern_WhenToUse1" xml:space="preserve">
    <value>To add operations to an object structure</value>
  </data>
  <data name="VisitorPattern_WhenToUse2" xml:space="preserve">
    <value>When structure is stable but operations change</value>
  </data>
  <data name="VisitorPattern_WhenToUse3" xml:space="preserve">
    <value>To separate algorithms from objects</value>
  </data>
  <data name="VisitorPattern_InteractiveDesc" xml:space="preserve">
    <value>Apply visitor:</value>
  </data>
  <data name="VisitorPattern_InteractiveButton" xml:space="preserve">
    <value>Visit Elements</value>
  </data>
  <data name="VisitorPattern_RealWorldDesc" xml:space="preserve">
    <value>Tax calculation: different asset types (stocks, bonds, real estate) accept a tax inspection visitor that applies specific rules to each type.</value>
  </data>
  <data name="VisitorPattern_Pros1" xml:space="preserve">
    <value>â€¢ Open/closed principle</value>
  </data>
  <data name="VisitorPattern_Pros2" xml:space="preserve">
    <value>â€¢ Single responsibility</value>
  </data>
  <data name="VisitorPattern_Pros3" xml:space="preserve">
    <value>â€¢ State accumulation</value>
  </data>
  <data name="VisitorPattern_Cons1" xml:space="preserve">
    <value>â€¢ Difficult if structure changes</value>
  </data>
  <data name="VisitorPattern_Cons2" xml:space="preserve">
    <value>â€¢ Private member access</value>
  </data>
  <data name="CleanArchitecture_Title" xml:space="preserve">
    <value>Clean Architecture</value>
  </data>
  <data name="CleanArchitecture_Architecture" xml:space="preserve">
    <value>Architecture</value>
  </data>
  <data name="CleanArchitecture_Description" xml:space="preserve">
    <value>Clean Architecture organizes code into independent layers with clear boundaries and dependencies pointing inward. Inner layers contain business logic and are independent of frameworks, UI, and databases.</value>
  </data>
  <data name="CleanArchitecture_PrinciplesTitle" xml:space="preserve">
    <value>Core Principles</value>
  </data>
  <data name="CleanArchitecture_Principle1Title" xml:space="preserve">
    <value>Independence</value>
  </data>
  <data name="CleanArchitecture_Principle1Desc" xml:space="preserve">
    <value>Business logic independent of frameworks</value>
  </data>
  <data name="CleanArchitecture_Principle2Title" xml:space="preserve">
    <value>Testability</value>
  </data>
  <data name="CleanArchitecture_Principle2Desc" xml:space="preserve">
    <value>Easy to test without UI or database</value>
  </data>
  <data name="CleanArchitecture_Principle3Title" xml:space="preserve">
    <value>Dependency Rule</value>
  </data>
  <data name="CleanArchitecture_Principle3Desc" xml:space="preserve">
    <value>Dependencies point only inward</value>
  </data>
  <data name="CleanArchitecture_LayersTitle" xml:space="preserve">
    <value>Architectural Layers</value>
  </data>
  <data name="CleanArchitecture_Layer1" xml:space="preserve">
    <value>Core</value>
  </data>
  <data name="CleanArchitecture_Layer1Desc" xml:space="preserve">
    <value>â†’ Entities, Business Rules</value>
  </data>
  <data name="CleanArchitecture_Layer2" xml:space="preserve">
    <value>Application</value>
  </data>
  <data name="CleanArchitecture_Layer2Desc" xml:space="preserve">
    <value>â†’ Use Cases, Interfaces</value>
  </data>
  <data name="CleanArchitecture_Layer3" xml:space="preserve">
    <value>Infrastructure</value>
  </data>
  <data name="CleanArchitecture_Layer3Desc" xml:space="preserve">
    <value>â†’ Database, External Services</value>
  </data>
  <data name="CleanArchitecture_Layer4" xml:space="preserve">
    <value>Presentation</value>
  </data>
  <data name="CleanArchitecture_Layer4Desc" xml:space="preserve">
    <value>â†’ UI, Controllers, ViewModels</value>
  </data>
  <data name="CleanArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Simulate a service call through the layers:</value>
  </data>
  <data name="CleanArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute Service Call</value>
  </data>
  <data name="CleanArchitecture_CodeTitle" xml:space="preserve">
    <value>Code Structure</value>
  </data>
  <data name="CleanArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Highly testable</value>
  </data>
  <data name="CleanArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Technology independent</value>
  </data>
  <data name="CleanArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Clear boundaries</value>
  </data>
  <data name="CleanArchitecture_Pros4" xml:space="preserve">
    <value>â€¢ Easy to maintain</value>
  </data>
  <data name="CleanArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Learning curve</value>
  </data>
  <data name="CleanArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ More boilerplate code</value>
  </data>
  <data name="CleanArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Overkill for small apps</value>
  </data>
  <data name="CleanArchitecture_Cons4" xml:space="preserve">
    <value>â€¢ Initial complexity</value>
  </data>
  <data name="CleanArchitecture_KeyPoint" xml:space="preserve">
    <value>Clean Architecture emphasizes separation of concerns and independence from external dependencies, making your codebase more maintainable, testable, and adaptable to change.</value>
  </data>
  <data name="Architecture_ConsTitle" xml:space="preserve">
    <value>Challenges</value>
  </data>
  <data name="Architecture_KeyPointTitle" xml:space="preserve">
    <value>Key Point</value>
  </data>
  <data name="CQRSArchitecture_Title" xml:space="preserve">
    <value>CQRS Architecture</value>
  </data>
  <data name="CQRSArchitecture_Description" xml:space="preserve">
    <value>CQRS (Command Query Responsibility Segregation) separates read and write operations using distinct models for updating and querying data.</value>
  </data>
  <data name="CQRSArchitecture_WhenToUse1" xml:space="preserve">
    <value>Systems with different read/write loads</value>
  </data>
  <data name="CQRSArchitecture_WhenToUse2" xml:space="preserve">
    <value>Complex domains requiring separate models</value>
  </data>
  <data name="CQRSArchitecture_WhenToUse3" xml:space="preserve">
    <value>Applications needing independent scalability</value>
  </data>
  <data name="CQRSArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Execute a command and query:</value>
  </data>
  <data name="CQRSArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute CQRS</value>
  </data>
  <data name="CQRSArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Optimized scalability</value>
  </data>
  <data name="CQRSArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Separation of concerns</value>
  </data>
  <data name="CQRSArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Improved performance</value>
  </data>
  <data name="CQRSArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Increased complexity</value>
  </data>
  <data name="CQRSArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Data synchronization</value>
  </data>
  <data name="CQRSArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Overkill for simple apps</value>
  </data>
  <data name="DDDArchitecture_Title" xml:space="preserve">
    <value>DDD Architecture</value>
  </data>
  <data name="DDDArchitecture_Description" xml:space="preserve">
    <value>Domain-Driven Design focuses on modeling the business domain and uses ubiquitous language shared between developers and domain experts.</value>
  </data>
  <data name="DDDArchitecture_WhenToUse1" xml:space="preserve">
    <value>Complex business domains</value>
  </data>
  <data name="DDDArchitecture_WhenToUse2" xml:space="preserve">
    <value>Close collaboration with domain experts</value>
  </data>
  <data name="DDDArchitecture_WhenToUse3" xml:space="preserve">
    <value>Long-term projects requiring scalability</value>
  </data>
  <data name="DDDArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Simulate domain operation:</value>
  </data>
  <data name="DDDArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute Domain Logic</value>
  </data>
  <data name="DDDArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Business alignment</value>
  </data>
  <data name="DDDArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Ubiquitous language</value>
  </data>
  <data name="DDDArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Centralized business logic</value>
  </data>
  <data name="DDDArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ High learning curve</value>
  </data>
  <data name="DDDArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Requires domain expertise</value>
  </data>
  <data name="DDDArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Initial complexity</value>
  </data>
  <data name="EventDrivenArchitecture_Title" xml:space="preserve">
    <value>Event-Driven Architecture</value>
  </data>
  <data name="EventDrivenArchitecture_Description" xml:space="preserve">
    <value>Event-driven architecture where components communicate through producing, detecting, and consuming asynchronous events.</value>
  </data>
  <data name="EventDrivenArchitecture_WhenToUse1" xml:space="preserve">
    <value>Systems requiring loose coupling</value>
  </data>
  <data name="EventDrivenArchitecture_WhenToUse2" xml:space="preserve">
    <value>Real-time applications</value>
  </data>
  <data name="EventDrivenArchitecture_WhenToUse3" xml:space="preserve">
    <value>Microservices and distributed systems</value>
  </data>
  <data name="EventDrivenArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Publish and consume an event:</value>
  </data>
  <data name="EventDrivenArchitecture_InteractiveButton" xml:space="preserve">
    <value>Publish Event</value>
  </data>
  <data name="EventDrivenArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Loose coupling</value>
  </data>
  <data name="EventDrivenArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ High scalability</value>
  </data>
  <data name="EventDrivenArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Real-time responsiveness</value>
  </data>
  <data name="EventDrivenArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Complex debugging</value>
  </data>
  <data name="EventDrivenArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Event management complexity</value>
  </data>
  <data name="EventDrivenArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Eventual consistency</value>
  </data>
  <data name="HexagonalArchitecture_Title" xml:space="preserve">
    <value>Hexagonal Architecture</value>
  </data>
  <data name="HexagonalArchitecture_Description" xml:space="preserve">
    <value>Hexagonal Architecture (Ports and Adapters) isolates business logic by defining ports and adapters for external interactions.</value>
  </data>
  <data name="HexagonalArchitecture_WhenToUse1" xml:space="preserve">
    <value>Independence from external technologies</value>
  </data>
  <data name="HexagonalArchitecture_WhenToUse2" xml:space="preserve">
    <value>Highly testable applications</value>
  </data>
  <data name="HexagonalArchitecture_WhenToUse3" xml:space="preserve">
    <value>Systems with multiple interfaces</value>
  </data>
  <data name="HexagonalArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Interact via ports and adapters:</value>
  </data>
  <data name="HexagonalArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute via Adapter</value>
  </data>
  <data name="HexagonalArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Technology independence</value>
  </data>
  <data name="HexagonalArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ High testability</value>
  </data>
  <data name="HexagonalArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Adaptability</value>
  </data>
  <data name="HexagonalArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Conceptual complexity</value>
  </data>
  <data name="HexagonalArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ More structural code</value>
  </data>
  <data name="HexagonalArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Learning curve</value>
  </data>
  <data name="LayeredArchitecture_Title" xml:space="preserve">
    <value>Layered Architecture</value>
  </data>
  <data name="LayeredArchitecture_Description" xml:space="preserve">
    <value>Layered Architecture organizes code into horizontal layers (presentation, business, data) with unidirectional dependencies.</value>
  </data>
  <data name="LayeredArchitecture_WhenToUse1" xml:space="preserve">
    <value>Traditional n-tier applications</value>
  </data>
  <data name="LayeredArchitecture_WhenToUse2" xml:space="preserve">
    <value>Teams with clear responsibilities</value>
  </data>
  <data name="LayeredArchitecture_WhenToUse3" xml:space="preserve">
    <value>Projects requiring simple separation</value>
  </data>
  <data name="LayeredArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Call through layers:</value>
  </data>
  <data name="LayeredArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute Layered Call</value>
  </data>
  <data name="LayeredArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Simple to understand</value>
  </data>
  <data name="LayeredArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Separation of responsibilities</value>
  </data>
  <data name="LayeredArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Easy to implement</value>
  </data>
  <data name="LayeredArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Monolithic dependencies</value>
  </data>
  <data name="LayeredArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Cascading changes</value>
  </data>
  <data name="LayeredArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Possible vertical coupling</value>
  </data>
  <data name="MicroservicesArchitecture_Title" xml:space="preserve">
    <value>Microservices Architecture</value>
  </data>
  <data name="MicroservicesArchitecture_Description" xml:space="preserve">
    <value>Microservices Architecture structures applications as loosely coupled, independently deployable services organized around business capabilities.</value>
  </data>
  <data name="MicroservicesArchitecture_WhenToUse1" xml:space="preserve">
    <value>Complex and large applications</value>
  </data>
  <data name="MicroservicesArchitecture_WhenToUse2" xml:space="preserve">
    <value>Multiple autonomous teams</value>
  </data>
  <data name="MicroservicesArchitecture_WhenToUse3" xml:space="preserve">
    <value>Independent deployments required</value>
  </data>
  <data name="MicroservicesArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Communicate between services:</value>
  </data>
  <data name="MicroservicesArchitecture_InteractiveButton" xml:space="preserve">
    <value>Call Service</value>
  </data>
  <data name="MicroservicesArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Independent scalability</value>
  </data>
  <data name="MicroservicesArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Independent deployments</value>
  </data>
  <data name="MicroservicesArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Heterogeneous technologies</value>
  </data>
  <data name="MicroservicesArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Operational complexity</value>
  </data>
  <data name="MicroservicesArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Network communication</value>
  </data>
  <data name="MicroservicesArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Data consistency challenges</value>
  </data>
  <data name="MVCArchitecture_Title" xml:space="preserve">
    <value>MVC Architecture</value>
  </data>
  <data name="MVCArchitecture_Description" xml:space="preserve">
    <value>Model-View-Controller separates applications into Model (data), View (UI), and Controller (logic) for clear separation of concerns.</value>
  </data>
  <data name="MVCArchitecture_WhenToUse1" xml:space="preserve">
    <value>Traditional web applications</value>
  </data>
  <data name="MVCArchitecture_WhenToUse2" xml:space="preserve">
    <value>UI/logic separation required</value>
  </data>
  <data name="MVCArchitecture_WhenToUse3" xml:space="preserve">
    <value>Server-side web development</value>
  </data>
  <data name="MVCArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Process an MVC request:</value>
  </data>
  <data name="MVCArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute MVC Request</value>
  </data>
  <data name="MVCArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Clear separation</value>
  </data>
  <data name="MVCArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Testability</value>
  </data>
  <data name="MVCArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Parallel development</value>
  </data>
  <data name="MVCArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Fat controllers</value>
  </data>
  <data name="MVCArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Learning curve</value>
  </data>
  <data name="MVCArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Complexity for small apps</value>
  </data>
  <data name="MVVMArchitecture_Title" xml:space="preserve">
    <value>MVVM Architecture</value>
  </data>
  <data name="MVVMArchitecture_Description" xml:space="preserve">
    <value>MVVM Architecture separates applications into Model, View, and ViewModel to facilitate data binding, improve testability, and separate presentation logic.</value>
  </data>
  <data name="MVVMArchitecture_WhenToUse1" xml:space="preserve">
    <value>Applications with complex data binding</value>
  </data>
  <data name="MVVMArchitecture_WhenToUse2" xml:space="preserve">
    <value>.NET MAUI, WPF, Xamarin applications</value>
  </data>
  <data name="MVVMArchitecture_WhenToUse3" xml:space="preserve">
    <value>When UI/logic separation is essential</value>
  </data>
  <data name="MVVMArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Update data via ViewModel:</value>
  </data>
  <data name="MVVMArchitecture_InteractiveButton" xml:space="preserve">
    <value>Update via ViewModel</value>
  </data>
  <data name="MVVMArchitecture_CodeTitle" xml:space="preserve">
    <value>Structure Example</value>
  </data>
  <data name="MVVMArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Clear UI/logic separation</value>
  </data>
  <data name="MVVMArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Powerful data binding</value>
  </data>
  <data name="MVVMArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ High testability</value>
  </data>
  <data name="MVVMArchitecture_Pros4" xml:space="preserve">
    <value>â€¢ Code reusability</value>
  </data>
  <data name="MVVMArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Significant boilerplate code</value>
  </data>
  <data name="MVVMArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Learning curve</value>
  </data>
  <data name="MVVMArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Complexity for small apps</value>
  </data>
  <data name="OnionArchitecture_Title" xml:space="preserve">
    <value>Onion Architecture</value>
  </data>
  <data name="OnionArchitecture_Description" xml:space="preserve">
    <value>Onion Architecture organizes code in concentric layers with the domain at the center, avoiding dependencies on infrastructure.</value>
  </data>
  <data name="OnionArchitecture_WhenToUse1" xml:space="preserve">
    <value>Domain-centric applications</value>
  </data>
  <data name="OnionArchitecture_WhenToUse2" xml:space="preserve">
    <value>Infrastructure independence required</value>
  </data>
  <data name="OnionArchitecture_WhenToUse3" xml:space="preserve">
    <value>Testability and maintainability priorities</value>
  </data>
  <data name="OnionArchitecture_InteractiveDesc" xml:space="preserve">
    <value>Navigate through layers:</value>
  </data>
  <data name="OnionArchitecture_InteractiveButton" xml:space="preserve">
    <value>Execute Through Layers</value>
  </data>
  <data name="OnionArchitecture_Pros1" xml:space="preserve">
    <value>â€¢ Isolated domain logic</value>
  </data>
  <data name="OnionArchitecture_Pros2" xml:space="preserve">
    <value>â€¢ Maximum testability</value>
  </data>
  <data name="OnionArchitecture_Pros3" xml:space="preserve">
    <value>â€¢ Clear dependencies</value>
  </data>
  <data name="OnionArchitecture_Cons1" xml:space="preserve">
    <value>â€¢ Initial complexity</value>
  </data>
  <data name="OnionArchitecture_Cons2" xml:space="preserve">
    <value>â€¢ Learning curve</value>
  </data>
  <data name="OnionArchitecture_Cons3" xml:space="preserve">
    <value>â€¢ Overkill for simple apps</value>
  </data>
  <data name="MainPage_Title" xml:space="preserve">
    <value>Welcome</value>
  </data>
  <data name="MainPage_AppName" xml:space="preserve">
    <value>Code Patterns</value>
  </data>
  <data name="MainPage_Tagline" xml:space="preserve">
    <value>Master Software Architecture, Design Patterns &amp; SOLID Principles</value>
  </data>
  <data name="MainPage_WelcomeTitle" xml:space="preserve">
    <value>Welcome! ðŸ‘‹</value>
  </data>
  <data name="MainPage_WelcomeDesc" xml:space="preserve">
    <value>Explore comprehensive design patterns, architectural styles, and SOLID principles used in modern software development. Learn through interactive examples and practical code demonstrations.</value>
  </data>
  <data name="MainPage_QuickAccessTitle" xml:space="preserve">
    <value>Quick Access</value>
  </data>
  <data name="MainPage_DesignPatternsCard" xml:space="preserve">
    <value>Design Patterns</value>
  </data>
  <data name="MainPage_DesignPatternsDesc" xml:space="preserve">
    <value>23 proven software design solutions</value>
  </data>
  <data name="MainPage_ArchitecturesCard" xml:space="preserve">
    <value>Software Architectures</value>
  </data>
  <data name="MainPage_ArchitecturesDesc" xml:space="preserve">
    <value>10 architectural patterns for scalable systems</value>
  </data>
  <data name="MainPage_SOLIDCard" xml:space="preserve">
    <value>SOLID Principles</value>
  </data>
  <data name="MainPage_SOLIDDesc" xml:space="preserve">
    <value>5 fundamental principles for robust design</value>
  </data>
  <data name="MainPage_QuizCard" xml:space="preserve">
    <value>Test Your Knowledge</value>
  </data>
  <data name="MainPage_QuizDesc" xml:space="preserve">
    <value>Interactive quizzes and challenges</value>
  </data>
  <data name="MainPage_PatternsCount" xml:space="preserve">
    <value>23</value>
  </data>
  <data name="MainPage_PatternsLabel" xml:space="preserve">
    <value>Design Patterns</value>
  </data>
  <data name="MainPage_ArchitecturesCount" xml:space="preserve">
    <value>10</value>
  </data>
  <data name="MainPage_ArchitecturesLabel" xml:space="preserve">
    <value>Architectures</value>
  </data>
  <data name="MainPage_SOLIDCount" xml:space="preserve">
    <value>5</value>
  </data>
  <data name="MainPage_SOLIDLabel" xml:space="preserve">
    <value>SOLID Principles</value>
  </data>
  <data name="MainPage_WhatYouLearnTitle" xml:space="preserve">
    <value>What You'll Learn</value>
  </data>
  <data name="MainPage_CreationalPatternsTitle" xml:space="preserve">
    <value>Creational Patterns</value>
  </data>
  <data name="MainPage_CreationalPatternsDesc" xml:space="preserve">
    <value>Object creation mechanisms</value>
  </data>
  <data name="MainPage_StructuralPatternsTitle" xml:space="preserve">
    <value>Structural Patterns</value>
  </data>
  <data name="MainPage_StructuralPatternsDesc" xml:space="preserve">
    <value>Class and object composition</value>
  </data>
  <data name="MainPage_BehavioralPatternsTitle" xml:space="preserve">
    <value>Behavioral Patterns</value>
  </data>
  <data name="MainPage_BehavioralPatternsDesc" xml:space="preserve">
    <value>Object collaboration and responsibilities</value>
  </data>
  <data name="MainPage_ArchitecturesTitle" xml:space="preserve">
    <value>Software Architectures</value>
  </data>
  <data name="MainPage_ArchitecturesTitle2" xml:space="preserve">
    <value>Large-scale system organization</value>
  </data>
  <data name="MainPage_SOLIDTitle" xml:space="preserve">
    <value>SOLID Principles</value>
  </data>
  <data name="MainPage_SOLIDTitle2" xml:space="preserve">
    <value>Foundations for robust object-oriented design</value>
  </data>
  <data name="DesignPatternsPage_Title" xml:space="preserve">
    <value>Design Patterns</value>
  </data>
  <data name="DesignPatternsPage_Tagline" xml:space="preserve">
    <value>23 proven solutions to common software design problems</value>
  </data>
  <data name="DesignPatternsPage_SearchPlaceholder" xml:space="preserve">
    <value>Search for patterns...</value>
  </data>
  <data name="DesignPatternsPage_NoResultsTitle" xml:space="preserve">
    <value>No patterns found</value>
  </data>
  <data name="DesignPatternsPage_NoResultsDesc" xml:space="preserve">
    <value>Try adjusting your search term</value>
  </data>
  <data name="ArchitecturesPage_Title" xml:space="preserve">
    <value>Software Architectures</value>
  </data>
  <data name="ArchitecturesPage_Tagline" xml:space="preserve">
    <value>10 architectural patterns for scalable systems</value>
  </data>
  <data name="ArchitecturesPage_SearchPlaceholder" xml:space="preserve">
    <value>Search for architectures...</value>
  </data>
  <data name="ArchitecturesPage_NoResultsTitle" xml:space="preserve">
    <value>No architectures found</value>
  </data>
  <data name="ArchitecturesPage_NoResultsDesc" xml:space="preserve">
    <value>Try adjusting your search term</value>
  </data>
  <data name="QuizPage_Title" xml:space="preserve">
    <value>Knowledge Quiz</value>
  </data>
  <data name="QuizPage_Tagline" xml:space="preserve">
    <value>Test your understanding</value>
  </data>
  <data name="QuizPage_TopicSelectionTitle" xml:space="preserve">
    <value>Choose a Topic</value>
  </data>
  <data name="QuizPage_TopicInputLabel" xml:space="preserve">
    <value>Enter the name of a pattern or architecture:</value>
  </data>
  <data name="QuizPage_TopicInputPlaceholder" xml:space="preserve">
    <value>e.g., Singleton, MVC, Clean Architecture...</value>
  </data>
  <data name="QuizPage_GenerateButton" xml:space="preserve">
    <value>ðŸŽ² Generate Question</value>
  </data>
  <data name="QuizPage_QuickTopicsTitle" xml:space="preserve">
    <value>Quick Topics</value>
  </data>
  <data name="QuizPage_QuestionTitle" xml:space="preserve">
    <value>Question</value>
  </data>
  <data name="QuizPage_YourAnswerLabel" xml:space="preserve">
    <value>Your Answer:</value>
  </data>
  <data name="QuizPage_AnswerPlaceholder" xml:space="preserve">
    <value>Enter A, B, C, or D</value>
  </data>
  <data name="QuizPage_SubmitButton" xml:space="preserve">
    <value>âœ“ Submit Answer</value>
  </data>
  <data name="QuizPage_ResultTitle" xml:space="preserve">
    <value>Result</value>
  </data>
  <data name="QuizPage_TipsTitle" xml:space="preserve">
    <value>Quiz Tips</value>
  </data>
  <data name="QuizPage_TipsContent" xml:space="preserve">
    <value>â€¢ Read each question carefully
â€¢ Think about real-world applications
â€¢ Review pattern details if unsure
â€¢ Practice makes perfect!</value>
  </data>
  <data name="SOLIDPrinciplesPage_Title" xml:space="preserve">
    <value>SOLID Principles</value>
  </data>
  <data name="SOLIDPrinciplesPage_Tagline" xml:space="preserve">
    <value>5 fundamental principles for robust object-oriented design</value>
  </data>
  <data name="SOLIDPrinciplesPage_SearchPlaceholder" xml:space="preserve">
    <value>Search for principles...</value>
  </data>
  <data name="SOLIDPrinciplesPage_NoResultsTitle" xml:space="preserve">
    <value>No principles found</value>
  </data>
  <data name="SOLIDPrinciplesPage_NoResultsDesc" xml:space="preserve">
    <value>Try adjusting your search term</value>
  </data>
  <data name="SOLID_Category" xml:space="preserve">
    <value>SOLID</value>
  </data>
  <data name="SOLID_KeyConceptsTitle" xml:space="preserve">
    <value>Key Concepts</value>
  </data>
  <data name="SOLID_InteractiveTitle" xml:space="preserve">
    <value>Interactive Example</value>
  </data>
  <data name="SOLID_BadExampleTitle" xml:space="preserve">
    <value>Bad Example (Violation)</value>
  </data>
  <data name="SOLID_GoodExampleTitle" xml:space="preserve">
    <value>Good Example (Follows Principle)</value>
  </data>
  <data name="SOLID_ShowViolationButton" xml:space="preserve">
    <value>Show Example âŒ (Violation)</value>
  </data>
  <data name="SOLID_ShowCorrectButton" xml:space="preserve">
    <value>Show Example âœ“ (Correct)</value>
  </data>
  <data name="SOLID_AdvantagesTitle" xml:space="preserve">
    <value>Advantages</value>
  </data>
  <data name="SOLID_AttentionPointsTitle" xml:space="preserve">
    <value>Points of Attention</value>
  </data>
  <data name="SRP_Title" xml:space="preserve">
    <value>Single Responsibility Principle</value>
  </data>
  <data name="SRP_KeyConcept1" xml:space="preserve">
    <value>One class = one responsibility</value>
  </data>
  <data name="SRP_KeyConcept2" xml:space="preserve">
    <value>Easier maintenance and understanding</value>
  </data>
  <data name="SRP_KeyConcept3" xml:space="preserve">
    <value>Reduces coupling between responsibilities</value>
  </data>
  <data name="SRP_KeyConcept4" xml:space="preserve">
    <value>Improves code reusability</value>
  </data>
  <data name="SRP_InteractiveDesc" xml:space="preserve">
    <value>Compare a class with multiple responsibilities vs separate classes:</value>
  </data>
  <data name="SRP_Advantage1" xml:space="preserve">
    <value>â€¢ More readable code</value>
  </data>
  <data name="SRP_Advantage2" xml:space="preserve">
    <value>â€¢ Simplified maintenance</value>
  </data>
  <data name="SRP_Advantage3" xml:space="preserve">
    <value>â€¢ Improved testability</value>
  </data>
  <data name="SRP_Advantage4" xml:space="preserve">
    <value>â€¢ Easier reusability</value>
  </data>
  <data name="SRP_Attention1" xml:space="preserve">
    <value>â€¢ Risk of over-fragmentation</value>
  </data>
  <data name="SRP_Attention2" xml:space="preserve">
    <value>â€¢ More classes to manage</value>
  </data>
  <data name="SRP_Attention3" xml:space="preserve">
    <value>â€¢ Defining "responsibility" is subjective</value>
  </data>
  <data name="OCP_Title" xml:space="preserve">
    <value>Open/Closed Principle</value>
  </data>
  <data name="OCP_KeyConcept1" xml:space="preserve">
    <value>Open for extension (inheritance, composition)</value>
  </data>
  <data name="OCP_KeyConcept2" xml:space="preserve">
    <value>Closed for modification (stable code)</value>
  </data>
  <data name="OCP_KeyConcept3" xml:space="preserve">
    <value>Use abstraction (interfaces, abstract classes)</value>
  </data>
  <data name="OCP_KeyConcept4" xml:space="preserve">
    <value>Avoids regressions during changes</value>
  </data>
  <data name="OCP_InteractiveDesc" xml:space="preserve">
    <value>Compare adding new features with/without OCP:</value>
  </data>
  <data name="OCP_Advantage1" xml:space="preserve">
    <value>â€¢ Risk-free extensibility</value>
  </data>
  <data name="OCP_Advantage2" xml:space="preserve">
    <value>â€¢ Reduced regressions</value>
  </data>
  <data name="OCP_Advantage3" xml:space="preserve">
    <value>â€¢ Stable and reliable code</value>
  </data>
  <data name="OCP_Advantage4" xml:space="preserve">
    <value>â€¢ Facilitates new features</value>
  </data>
  <data name="OCP_Attention1" xml:space="preserve">
    <value>â€¢ Anticipation required</value>
  </data>
  <data name="OCP_Attention2" xml:space="preserve">
    <value>â€¢ More abstractions</value>
  </data>
  <data name="OCP_Attention3" xml:space="preserve">
    <value>â€¢ Increased initial complexity</value>
  </data>
  <data name="LSP_Title" xml:space="preserve">
    <value>Liskov Substitution Principle</value>
  </data>
  <data name="LSP_KeyConcept1" xml:space="preserve">
    <value>Subtypes must be substitutable</value>
  </data>
  <data name="LSP_KeyConcept2" xml:space="preserve">
    <value>Respect base class contracts</value>
  </data>
  <data name="LSP_KeyConcept3" xml:space="preserve">
    <value>Don't violate client expectations</value>
  </data>
  <data name="LSP_KeyConcept4" xml:space="preserve">
    <value>Ensures hierarchy consistency</value>
  </data>
  <data name="LSP_InteractiveDesc" xml:space="preserve">
    <value>Compare a correct hierarchy with an LSP violation:</value>
  </data>
  <data name="LSP_Advantage1" xml:space="preserve">
    <value>â€¢ Reliable polymorphism</value>
  </data>
  <data name="LSP_Advantage2" xml:space="preserve">
    <value>â€¢ Predictable behavior</value>
  </data>
  <data name="LSP_Advantage3" xml:space="preserve">
    <value>â€¢ Robust hierarchies</value>
  </data>
  <data name="LSP_Advantage4" xml:space="preserve">
    <value>â€¢ Facilitates testing</value>
  </data>
  <data name="LSP_Attention1" xml:space="preserve">
    <value>â€¢ Hard to identify violations</value>
  </data>
  <data name="LSP_Attention2" xml:space="preserve">
    <value>â€¢ Requires good design</value>
  </data>
  <data name="LSP_Attention3" xml:space="preserve">
    <value>â€¢ May limit inheritance</value>
  </data>
  <data name="ISP_Title" xml:space="preserve">
    <value>Interface Segregation Principle</value>
  </data>
  <data name="ISP_KeyConcept1" xml:space="preserve">
    <value>Small and specific interfaces</value>
  </data>
  <data name="ISP_KeyConcept2" xml:space="preserve">
    <value>Avoid fat interfaces</value>
  </data>
  <data name="ISP_KeyConcept3" xml:space="preserve">
    <value>Clients depend only on what they need</value>
  </data>
  <data name="ISP_KeyConcept4" xml:space="preserve">
    <value>Reduces unnecessary coupling</value>
  </data>
  <data name="ISP_InteractiveDesc" xml:space="preserve">
    <value>Compare a monolithic interface with segregated interfaces:</value>
  </data>
  <data name="ISP_Advantage1" xml:space="preserve">
    <value>â€¢ Reduced coupling</value>
  </data>
  <data name="ISP_Advantage2" xml:space="preserve">
    <value>â€¢ Clear and focused interfaces</value>
  </data>
  <data name="ISP_Advantage3" xml:space="preserve">
    <value>â€¢ Increased flexibility</value>
  </data>
  <data name="ISP_Advantage4" xml:space="preserve">
    <value>â€¢ Simpler implementations</value>
  </data>
  <data name="ISP_Attention1" xml:space="preserve">
    <value>â€¢ Interface proliferation</value>
  </data>
  <data name="ISP_Attention2" xml:space="preserve">
    <value>â€¢ Navigation complexity</value>
  </data>
  <data name="ISP_Attention3" xml:space="preserve">
    <value>â€¢ Balance to be found</value>
  </data>
  <data name="DIP_Title" xml:space="preserve">
    <value>Dependency Inversion Principle</value>
  </data>
  <data name="DIP_KeyConcept1" xml:space="preserve">
    <value>Depend on abstractions (interfaces) not implementations</value>
  </data>
  <data name="DIP_KeyConcept2" xml:space="preserve">
    <value>High-level modules independent of details</value>
  </data>
  <data name="DIP_KeyConcept3" xml:space="preserve">
    <value>Dependency Injection (DI) for flexibility</value>
  </data>
  <data name="DIP_KeyConcept4" xml:space="preserve">
    <value>Facilitates testing and implementation changes</value>
  </data>
  <data name="DIP_InteractiveDesc" xml:space="preserve">
    <value>Compare tight coupling with dependency inversion:</value>
  </data>
  <data name="DIP_ShowViolationButton" xml:space="preserve">
    <value>Show Example âŒ (Violation)</value>
  </data>
  <data name="DIP_ShowCorrectButton" xml:space="preserve">
    <value>Show Example âœ“ (Follows DIP)</value>
  </data>
  <data name="DIP_Advantage1" xml:space="preserve">
    <value>â€¢ Reduced coupling</value>
  </data>
  <data name="DIP_Advantage2" xml:space="preserve">
    <value>â€¢ Maximum flexibility</value>
  </data>
  <data name="DIP_Advantage3" xml:space="preserve">
    <value>â€¢ Easier testing (mocking)</value>
  </data>
  <data name="DIP_Advantage4" xml:space="preserve">
    <value>â€¢ Simple implementation changes</value>
  </data>
  <data name="DIP_Attention1" xml:space="preserve">
    <value>â€¢ Requires DI container</value>
  </data>
  <data name="DIP_Attention2" xml:space="preserve">
    <value>â€¢ More abstractions to create</value>
  </data>
  <data name="DIP_Attention3" xml:space="preserve">
    <value>â€¢ Initial learning curve</value>
  </data>
  <data name="Singleton_Description" xml:space="preserve">
    <value>Ensures a class has only one instance.</value>
  </data>
  <data name="Factory_Description" xml:space="preserve">
    <value>Creates objects without exposing creation logic.</value>
  </data>
  <data name="AbstractFactory_Description" xml:space="preserve">
    <value>Creates families of related objects.</value>
  </data>
  <data name="Builder_Description" xml:space="preserve">
    <value>Builds complex objects step by step.</value>
  </data>
  <data name="Prototype_Description" xml:space="preserve">
    <value>Creates objects by cloning.</value>
  </data>
  <data name="Adapter_Description" xml:space="preserve">
    <value>Converts the interface of a class.</value>
  </data>
  <data name="Bridge_Description" xml:space="preserve">
    <value>Separates abstraction from implementation.</value>
  </data>
  <data name="Composite_Description" xml:space="preserve">
    <value>Tree structure of objects.</value>
  </data>
  <data name="Decorator_Description" xml:space="preserve">
    <value>Adds functionality dynamically.</value>
  </data>
  <data name="Facade_Description" xml:space="preserve">
    <value>Simplified interface.</value>
  </data>
  <data name="Flyweight_Description" xml:space="preserve">
    <value>Shares objects for efficiency.</value>
  </data>
  <data name="Proxy_Description" xml:space="preserve">
    <value>Provides a substitute or placeholder.</value>
  </data>
  <data name="ChainOfResponsibility_Description" xml:space="preserve">
    <value>Chain of processing handlers.</value>
  </data>
  <data name="Command_Description" xml:space="preserve">
    <value>Encapsulates a request as an object.</value>
  </data>
  <data name="Interpreter_Description" xml:space="preserve">
    <value>Interprets a grammar or language.</value>
  </data>
  <data name="Iterator_Description" xml:space="preserve">
    <value>Iterates through a collection.</value>
  </data>
  <data name="Mediator_Description" xml:space="preserve">
    <value>Centralized communication.</value>
  </data>
  <data name="Memento_Description" xml:space="preserve">
    <value>Saves and restores object state.</value>
  </data>
  <data name="Observer_Description" xml:space="preserve">
    <value>Notifies observers of changes.</value>
  </data>
  <data name="State_Description" xml:space="preserve">
    <value>Behavior changes with state.</value>
  </data>
  <data name="Strategy_Description" xml:space="preserve">
    <value>Interchangeable algorithms.</value>
  </data>
  <data name="TemplateMethod_Description" xml:space="preserve">
    <value>Defines algorithm skeleton.</value>
  </data>
  <data name="Visitor_Description" xml:space="preserve">
    <value>Separates algorithm from structure.</value>
  </data>
  <data name="MVC_Description" xml:space="preserve">
    <value>Model-View-Controller pattern.</value>
  </data>
  <data name="MVVM_Description" xml:space="preserve">
    <value>Model-View-ViewModel pattern.</value>
  </data>
  <data name="Clean_Description" xml:space="preserve">
    <value>Strict separation of responsibilities.</value>
  </data>
  <data name="Layered_Description" xml:space="preserve">
    <value>Layered architecture.</value>
  </data>
  <data name="Hexagonal_Description" xml:space="preserve">
    <value>Ports and Adapters architecture.</value>
  </data>
  <data name="Microservices_Description" xml:space="preserve">
    <value>Independent distributed services.</value>
  </data>
  <data name="EventDriven_Description" xml:space="preserve">
    <value>Event-based communication.</value>
  </data>
  <data name="CQRS_Description" xml:space="preserve">
    <value>Command-Query Responsibility Segregation.</value>
  </data>
  <data name="Onion_Description" xml:space="preserve">
    <value>Concentric layered architecture.</value>
  </data>
  <data name="DDD_Description" xml:space="preserve">
    <value>Domain-Driven Design.</value>
  </data>
  <data name="SRP_Description" xml:space="preserve">
    <value>A class should have only one reason to change.</value>
  </data>
  <data name="OCP_Description" xml:space="preserve">
    <value>Software entities should be open for extension but closed for modification.</value>
  </data>
  <data name="LSP_Description" xml:space="preserve">
    <value>Objects of a derived class should be able to replace objects of the base class.</value>
  </data>
  <data name="ISP_Description" xml:space="preserve">
    <value>Clients should not be forced to depend on interfaces they do not use.</value>
  </data>
  <data name="DIP_Description" xml:space="preserve">
    <value>Depend on abstractions, not concrete implementations.</value>
  </data>
</root>